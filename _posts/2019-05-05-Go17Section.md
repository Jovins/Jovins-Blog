---
layout: post
title: "17-Go语言字符串和正则表达式"
date: 2019-05-05 00:11:00.000000000 +09:00
categories: [Go]
tags: [Go, Go 正则表达式]
---

## 字符串相关方法

- 获取字符串长度
  - 注意: Go语言编码方式是UTF-8,在UTF-8中一个汉字占3个字节

```go
package main
import "fmt"
func main() {
    str1 := "zhangsan"
    fmt.Println(len(str1)) // 3
    str2 := "zhangsan张三"
    fmt.Println(len(str2)) // 12
}
```

- 如果字符串中包含中文, 又想精确的计算字符串中字符的个数而不是占用的字节, 那么必须先将字符串转换为rune类型数组
  - Go语言中byte用于保存字符, rune用于保存汉字

```go
package main
import "fmt"
func main() {
    str := "zhangsan张三"
    // 注意byte占1个字节, 只能保存字符不能保存汉字,因为一个汉字占用3个字节
    arr1 := []byte(str) // 12
    fmt.Println(len(arr1))
    for _, v := range arr1{
        fmt.Printf("%c", v) // zsæ��å��æ±�
    }

    // Go语言中rune类型就是专门用于保存汉字的
    arr2 := []rune(str)
    fmt.Println(len(arr2)) // 6
    for _, v := range arr2{
        fmt.Printf("%c", v) // zhangsan张三
    }
}

```

- 查找子串在字符串中出现的位置
  - func Index(s, sep string) int
  - func IndexByte(s string, c byte) int
  - func IndexRune(s string, r rune) int
  - func IndexAny(s, chars string) int
  - func IndexFunc(s string, f func(rune) bool) int
  - func LastIndex(s, sep string) int
  - func LastIndexByte(s string, c byte) int
  - func LastIndexAny(s, chars string) int
  - func LastIndexFunc(s string, f func(rune) bool) int

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 查找`字符`在字符串中第一次出现的位置, 找不到返回-1
    res := strings.IndexByte("hello 张三", 'l')
    fmt.Println(res) // 2

    // 查找`汉字`OR`字符`在字符串中第一次出现的位置, 找不到返回-1
    res = strings.IndexRune("hello 张三", '张')
    fmt.Println(res) // 6
    res = strings.IndexRune("hello 张三", 'l')
    fmt.Println(res) // 2

    // 查找`汉字`OR`字符`中任意一个在字符串中第一次出现的位置, 找不到返回-1
    res = strings.IndexAny("hello 张三", "wml")
    fmt.Println(res) // 2
    // 会把wmhl拆开逐个查找, w、m、h、l只要任意一个被找到, 立刻停止查找
    res = strings.IndexAny("hello 张三", "wmhl")
    fmt.Println(res) // 0
    // 查找`子串`在字符串第一次出现的位置, 找不到返回-1
    res = strings.Index("hello 张三", "llo")
    fmt.Println(res) // 2
    // 会把lle当做一个整体去查找, 而不是拆开
    res = strings.Index("hello 张三", "lle")
    fmt.Println(res) // -1
    // 可以查找字符也可以查找汉字
    res = strings.Index("hello 张三", "李")
    fmt.Println(res) // 6

    // 会将字符串先转换为[]rune, 然后遍历rune切片逐个取出传给自定义函数
    // 只要函数返回true,代表符合我们的需求, 既立即停止查找
    res = strings.IndexFunc("hello 张三", custom)
    fmt.Println(res) // 6

    // 倒序查找`子串`在字符串第一次出现的位置, 找不到返回-1
    res := strings.LastIndex("hello 张三", "l")
    fmt.Println(res) // 3
}
func custom(r rune) bool {
    fmt.Printf("被调用了, 当前传入的是%c\n", r)
    if r == 'o' {
        return true
    }
    return false
}
```

- 判断字符串中是否包含子串
  - func Contains(s, substr string) bool
  - func ContainsRune(s string, r rune) bool
  - func ContainsAny(s, chars string) bool
  - func HasPrefix(s, prefix string) bool
  - func HasSuffix(s, suffix string) bool

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 查找`子串`在字符串中是否存在, 存在返回true, 不存在返回false
    // 底层实现就是调用strings.Index函数
    res := strings.Contains( "hello 张三", "llo")
    fmt.Println(res) // true

    // 查找`汉字`OR`字符`在字符串中是否存在, 存在返回true, 不存在返回false
    // 底层实现就是调用strings.IndexRune函数
    res = strings.ContainsRune( "hello 张三", 'l')
    fmt.Println(res) // true
    res = strings.ContainsRune( "hello 张三", '张')
    fmt.Println(res) // true

    // 查找`汉字`OR`字符`中任意一个在字符串中是否存在, 存在返回true, 不存在返回false
    // 底层实现就是调用strings.IndexAny函数
    res = strings.ContainsAny( "hello 张三", "wmhl")
    fmt.Println(res) // true

    // 判断字符串是否已某个字符串开头
    res = strings.HasPrefix("zs-book.avi", "zs")
    fmt.Println(res) // true

    // 判断字符串是否已某个字符串结尾
    res = strings.HasSuffix("zs-book.avi", ".avi")
    fmt.Println(res) // true
}

```

- 字符串比较
  - func Compare(a, b string) int
  - func EqualFold(s, t string) bool

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 比较两个字符串大小, 会逐个字符地进行比较ASCII值
    // 第一个参数 >  第二个参数 返回 1
    // 第一个参数 <  第二个参数 返回 -1
    // 第一个参数 == 第二个参数 返回 0
    res := strings.Compare("bcd", "abc")
    fmt.Println(res) // 1
    res = strings.Compare("bcd", "bdc")
    fmt.Println(res) // -1
    res = strings.Compare("bcd", "bcd")
    fmt.Println(res) // 0

    // 判断两个字符串是否相等, 可以判断字符和中文
    // 判断时会忽略大小写进行判断
    res2 := strings.EqualFold("abc", "def")
    fmt.Println(res2) // false
    res2 = strings.EqualFold("abc", "abc")
    fmt.Println(res2) // true
    res2 = strings.EqualFold("abc", "ABC")
    fmt.Println(res2) // true
    res2 = strings.EqualFold("张三", "张三")
    fmt.Println(res2) // true
}
```

- 字符串转换
  - func ToUpper(s string) string
  - func ToLower(s string) string
  - func ToTitle(s string) string
  - func ToUpperSpecial(_case unicode.SpecialCase, s string) string
  - func ToLowerSpecial(_case unicode.SpecialCase, s string) string
  - func ToTitleSpecial(_case unicode.SpecialCase, s string) string
  - func Title(s string) string

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 将字符串转换为小写
    res := strings.ToLower("ABC")
    fmt.Println(res) // abc
    
    // 将字符串转换为大写
    res = strings.ToUpper("abc")
    fmt.Println(res) // ABC

    // 将字符串转换为标题格式, 大部分`字符`标题格式就是大写
    res = strings.ToTitle("hello world")
    fmt.Println(res) // HELLO WORLD
    res = strings.ToTitle("HELLO WORLD")
    fmt.Println(res) // HELLO WORLD

    // 将单词首字母变为大写, 其它字符不变
    // 单词之间用空格OR特殊字符隔开
    res = strings.Title("hello world")
    fmt.Println(res) // Hello World
}
```

- 字符串拆合
  - func Split(s, sep string) []string
  - func SplitN(s, sep string, n int) []string
  - func SplitAfter(s, sep string) []string
  - func SplitAfterN(s, sep string, n int) []string
  - func Fields(s string) []string
  - func FieldsFunc(s string, f func(rune) bool) []string
  - func Join(a []string, sep string) string
  - func Repeat(s string, count int) string
  - func Replace(s, old, new string, n int) string

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 按照指定字符串切割原字符串
    // 用,切割字符串
    arr1 := strings.Split("a,b,c", ",")
    fmt.Println(arr1) // [a b c]
    arr2 := strings.Split("ambmc", "m")
    fmt.Println(arr2) // [a b c]

    // 按照指定字符串切割原字符串, 并且指定切割为几份
    // 如果最后一个参数为0, 那么会范围一个空数组
    arr3 := strings.SplitN("a,b,c", ",", 2)
    fmt.Println(arr3) // [a b,c]
    arr4 := strings.SplitN("a,b,c", ",", 0)
    fmt.Println(arr4) // []

    // 按照指定字符串切割原字符串, 切割时包含指定字符串
    arr5 := strings.SplitAfter("a,b,c", ",")
    fmt.Println(arr5) // [a, b, c]

    // 按照指定字符串切割原字符串, 切割时包含指定字符串, 并且指定切割为几份
    arr6 := strings.SplitAfterN("a,b,c", ",", 2)
    fmt.Println(arr6) // [a, b,c]

    // 按照空格切割字符串, 多个空格会合并为一个空格处理
    arr7 := strings.Fields("a  b c    d")
    fmt.Println(arr7) // [a b c d]

    // 将字符串转换成切片传递给函数之后由函数决定如何切割
    // 类似于IndexFunc
    arr8 := strings.FieldsFunc("a,b,c", custom)
    fmt.Println(arr8) // [a b c]

    // 将字符串切片按照指定连接符号转换为字符串
    sce := []string{"aa", "bb", "cc"}
    str1 := strings.Join(sce, "-")
    fmt.Println(str1) // aa-bb-cc


    // 返回count个s串联的指定字符串
    str2 := strings.Repeat("abc", 2)
    fmt.Println(str2) // abcabc

    // 第一个参数: 需要替换的字符串
    // 第二个参数: 旧字符串
    // 第三个参数: 新字符串
    // 第四个参数: 用新字符串 替换 多少个旧字符串
    // 注意点: 传入-1代表只要有旧字符串就替换
    // 注意点: 替换之后会生成新字符串, 原字符串不会受到影响
    str3 := "abcdefabcdefabc"
    str4 := strings.Replace(str3, "abc", "mmm", -1)
    fmt.Println(str3) // abcdefabcdefabc
    fmt.Println(str4) // mmmdefmmmdefmmm
}
func custom(r rune) bool {
    fmt.Printf("被调用了, 当前传入的是%c\n", r)
    if r == ',' {
        return true
    }
    return false
}
```

- 字符串清理
  - func Trim(s string, cutset string) string
  - func TrimLeft(s string, cutset string) string
  - func TrimRight(s string, cutset string) string
  - func TrimFunc(s string, f func(rune) bool) string
  - func TrimLeftFunc(s string, f func(rune) bool) string
  - func TrimRightFunc(s string, f func(rune) bool) string
  - func TrimSpace(s string) string
  - func TrimPrefix(s, prefix string) string
  - func TrimSuffix(s, suffix string) string

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 去除字符串两端指定字符
    str1 := strings.Trim("!!!abc!!!def!!!", "!")
    fmt.Println(str1) // abc!!!def
    // 去除字符串左端指定字符
    str2 := strings.TrimLeft("!!!abc!!!def!!!", "!")
    fmt.Println(str2) // abc!!!def!!!
    // 去除字符串右端指定字符
    str3 := strings.TrimRight("!!!abc!!!def!!!", "!")
    fmt.Println(str3) // !!!abc!!!def
    // // 去除字符串两端空格
    str4 := strings.TrimSpace("   abc!!!def ")
    fmt.Println(str4) // abc!!!def

    // 按照方法定义规则,去除字符串两端符合规则内容
    str5 := strings.TrimFunc("!!!abc!!!def!!!", custom)
    fmt.Println(str5) // abc!!!def
    // 按照方法定义规则,去除字符串左端符合规则内容
    str6 := strings.TrimLeftFunc("!!!abc!!!def!!!", custom)
    fmt.Println(str6) // abc!!!def!!!
    //  按照方法定义规则,去除字符串右端符合规则内容
    str7 := strings.TrimRightFunc("!!!abc!!!def!!!", custom)
    fmt.Println(str7) // !!!abc!!!def

    // 取出字符串开头的指定字符串
    str8 := strings.TrimPrefix("zs-book.avi", "zs-")
    fmt.Println(str8) // book.avi

    // 取出字符串结尾的指定字符串
    str9 := strings.TrimSuffix("zs-book.avi", ".avi")
    fmt.Println(str9) // zs-book
}
```

## 正则表达式

- 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
- 相关规则标准详见
  - [百度百科](https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin)
  - [Go语言官方文档](https://studygolang.com/pkgdoc)regexp包
- Go语言中正则表达式使用步骤
  - 1.创建一个正则表达式匹配规则对象
  - 2.利用正则表达式匹配规则对象匹配指定字符串

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    // 创建一个正则表达式匹配规则对象
    // reg := regexp.MustCompile(规则字符串)
    // 利用正则表达式匹配规则对象匹配指定字符串
    // 会将所有匹配到的数据放到一个字符串切片中返回
    // 如果没有匹配到数据会返回nil
    // res := reg.FindAllString(需要匹配的字符串, 匹配多少个)

    str := "Hello 李南江 1232"
    reg := regexp.MustCompile("2")
    res := reg.FindAllString(str, -1)
    fmt.Println(res) // [2 2]
    res = reg.FindAllString(str, 1)
    fmt.Println(res) // [2]
}
```

- 匹配电话号码

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    res2 := findPhoneNumber("13554499311")
    fmt.Println(res2) // true

    res2 = findPhoneNumber("03554499311")
    fmt.Println(res2) // false

    res2 = findPhoneNumber("1355449931")
    fmt.Println(res2) // false
}
func findPhoneNumber(str string) bool {
    // 创建一个正则表达式匹配规则对象
    reg := regexp.MustCompile("^1[1-9]{10}")
    // 利用正则表达式匹配规则对象匹配指定字符串
    res := reg.FindAllString(str, -1)
    if(res == nil){
        return  false
    }
    return  true
}
```

- 匹配Email

```go
package main
import (
    "strings"
    "fmt"
)
func main() {
    res2 = findEmail("123@qq.com")
    fmt.Println(res2) // true

    res2 = findEmail("ab?de@qq.com")
    fmt.Println(res2) // false

    res2 = findEmail("123@qqcom")
    fmt.Println(res2) // false
}
func findEmail(str string) bool {
    reg := regexp.MustCompile("^[a-zA-Z0-9_]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+")
    res := reg.FindAllString(str, -1)
    if(res == nil){
        return  false
    }
    return  true
}
```