---
layout: post
title: "13-Go语言指针"
date: 2019-05-04 21:22:00.000000000 +09:00
categories: [Go]
tags: [Go, Go 指针]
---

## 普通指针

- 和C语言一样, 允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量
- 和C语言一样, Go语言中的指针无论是什么类型占用内存都一样(32位4个字节, 64位8个字节)

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {

    var p1 *int;
    var p2 *float64;
    var p3 *bool;
    fmt.Println(unsafe.Sizeof(p1)) // 8
    fmt.Println(unsafe.Sizeof(p2)) // 8
    fmt.Println(unsafe.Sizeof(p3)) // 8
}
```

- 和C语言一样, 只要一个指针变量保存了另一个变量对应的内存地址, 那么就可以通过*来访问指针变量指向的存储空间

```go
package main

import (
    "fmt"
)

func main() {

    // 1.定义一个普通变量
    var num int = 666
    // 2.定义一个指针变量
    var p *int = &num
    fmt.Printf("%p\n", &num) // 0xc042064080
    fmt.Printf("%p\n", p) // 0xc042064080
    fmt.Printf("%T\n", p) // *int
    // 3.通过指针变量操作指向的存储空间
    *p = 888
    // 4.指针变量操作的就是指向变量的存储空间
    fmt.Println(num) // 888
    fmt.Println(*p) // 888
}
```

## 指向数组指针

- 在C语言中, 数组名,&数组名,&数组首元素保存的都是同一个地址

```go
#include <stdio.h>

int main(){
     int arr[3] = {1, 3, 5};
     printf("%p\n", arr); // 0060FEA4
     printf("%p\n", &arr); // 0060FEA4
     printf("%p\n", &arr[0]); // 0060FEA4
}
```

- 在Go语言中通过数组名无法直接获取数组的内存地址

```go
package main
import "fmt"

func main() {
    var arr [3]int = [3]int{1, 3, 5}
    fmt.Printf("%p\n", arr) // 乱七八糟东西
    fmt.Printf("%p\n", &arr) // 0xc0420620a0
    fmt.Printf("%p\n", &arr[0]) // 0xc0420620a0
}
```

- 在C语言中, 无论我们将数组名,&数组名,&数组首元素赋值给指针变量, 都代表指针变量指向了这个数组

```go
#include <stdio.h>

int main(){
     int arr[3] = {1, 3, 5};
     int *p1 = arr;
     p1[1] = 6;
     printf("%d\n", arr[1]);

     int *p2 = &arr;
     p2[1] = 7;
     printf("%d\n", arr[1]);

     int *p3 = &arr[0];
     p3[1] = 8;
     printf("%d\n", arr[1]);
}
```

- 在Go语言中, 因为只有数据类型一模一样才能赋值, 所以只能通过&数组名赋值给指针变量, 才代表指针变量指向了这个数组

```go
package main

import "fmt"

func main() {
    // 1.错误, 在Go语言中必须类型一模一样才能赋值
    // arr类型是[3]int, p1的类型是*[3]int
    var p1 *[3]int
    fmt.Printf("%T\n", arr)
    fmt.Printf("%T\n", p1)
    p1 = arr // 报错
    p1[1] = 6
    fmt.Println(arr[1])

    // 2.正确, &arr的类型是*[3]int, p2的类型也是*[3]int
    var p2 *[3]int
    fmt.Printf("%T\n", &arr)
    fmt.Printf("%T\n", p2)
    p2 = &arr
    p2[1] = 6
    fmt.Println(arr[1])

    // 3.错误, &arr[0]的类型是*int, p3的类型也是*[3]int
    var p3 *[3]int
    fmt.Printf("%T\n", &arr[0])
    fmt.Printf("%T\n", p3)
    p3 = &arr[0] // 报错
    p3[1] = 6
    fmt.Println(arr[1])
}
```

- 注意点:
  - Go语言中的指针, 不支持C语言中的+1 -1和++ -- 操作

```go
package main

import "fmt"

func main() {

    var arr [3]int = [3]int{1, 3, 5}
    var p *[3]int
    p = &arr
    fmt.Printf("%p\n", &arr) // 0xc0420620a0
    fmt.Printf("%p\n", p) // 0xc0420620a0
    fmt.Println(&arr) // &[1 3 5]
    fmt.Println(p) // &[1 3 5]
    // 指针指向数组之后操作数组的几种方式
    // 1.直接通过数组名操作
    arr[1] = 6
    fmt.Println(arr[1])
    // 2.通过指针间接操作
    (*p)[1] = 7
    fmt.Println((*p)[1])
    fmt.Println(arr[1])
    // 3.通过指针间接操作
    p[1] = 8
    fmt.Println(p[1])
    fmt.Println(arr[1])

    // 注意点: Go语言中的指针, 不支持+1 -1和++ --操作
    *(p + 1) = 9 // 报错
    fmt.Println(*p++) // 报错
    fmt.Println(arr[1])
}
```

## 指向切片的指针

- 值得注意点的是切片的本质就是一个指针指向数组, 所以指向切片的指针是一个二级指针

![](/assets/images/2019Go/go-go13section-01.png)

![](/assets/images/2019Go/go-go13section-02.png)

```go
package main

import "fmt"

func main() {
    // 1.定义一个切片
    var sce[]int = []int{1, 3, 5}
    // 2.打印切片的地址
    // 切片变量中保存的地址, 也就是指向的那个数组的地址 sce = 0xc0420620a0
    fmt.Printf("sce = %p\n",sce )
    fmt.Println(sce) // [1 3 5]
    // 切片变量自己的地址, &sce = 0xc04205e3e0
    fmt.Printf("&sce = %p\n",&sce )
    fmt.Println(&sce) // &[1 3 5]
    // 3.定义一个指向切片的指针
    var p *[]int
    // 因为必须类型一致才能赋值, 所以将切片变量自己的地址给了指针
    p = &sce
    // 4.打印指针保存的地址
    // 直接打印p打印出来的是保存的切片变量的地址 p = 0xc04205e3e0
    fmt.Printf("p = %p\n", p)
    fmt.Println(p) // &[1 3 5]
    // 打印*p打印出来的是切片变量保存的地址, 也就是数组的地址 *p = 0xc0420620a0
    fmt.Printf("*p = %p\n", *p)
    fmt.Println(*p) // [1 3 5]
    
    // 5.修改切片的值
    // 通过*p找到切片变量指向的存储空间(数组), 然后修改数组中保存的数据
    (*p)[1] = 666
    fmt.Println(sce[1])
}
```

## 指向字典指针

- 与普通指针并无差异

```go
package main
import "fmt"
func main() {

    var dict map[string]string = map[string]string{"name":"lnj", "age":"33"}
    var p *map[string]string = &dict
    (*p)["name"] = "zs"
    fmt.Println(dict)
}
```

## 指向结构体指针

- Go语言中指向结构体的指针和C语言一样

- 结构体和指针

  - 创建结构体指针变量有两种方式

  ```go
  package main
  import "fmt"
  type Student struct {
      name string
      age int
  }
  func main() {
    // 创建时利用取地址符号获取结构体变量地址
    var p1 = &Student{"lnj", 33}
    fmt.Println(p1) // &{lnj 33}
  
    // 通过new内置函数传入数据类型创建
    // 内部会创建一个空的结构体变量, 然后返回这个结构体变量的地址
    var p2 = new(Student)
    fmt.Println(p2) // &{ 0}
  }
  ```

  - 利用结构体指针操作结构体属性

  ```go
  package main
  import "fmt"
  type Student struct {
      name string
      age int
  }
  func main() {
    var p = &Student{}
    // 方式一: 传统方式操作
    // 修改结构体中某个属性对应的值
    // 注意: 由于.运算符优先级比*高, 所以一定要加上()
    (*p).name = "lnj"
    // 获取结构体中某个属性对应的值
    fmt.Println((*p).name) // lnj
  
    // 方式二: 通过Go语法糖操作
    // Go语言作者为了程序员使用起来更加方便, 在操作指向结构体的指针时可以像操作接头体变量一样通过.来操作
    // 编译时底层会自动转发为(*p).age方式
    p.age = 33
    fmt.Println(p.age) // 33
  }
  ```

## 指针作为函数参数和返回值

- 如果指针类型作为函数参数, 修改形参会影响实参
- 不能将函数内的指向局部变量的指针作为返回值, 函数结束指向空间会被释放
- 可以将函数内的局部变量作为返回值, 本质是拷贝一份