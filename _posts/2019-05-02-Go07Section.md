---
layout: post
title: "07-Go语言命令行参数"
date: 2019-05-02 23:22:00.000000000 +09:00
categories: [Go]
tags: [Go]
---

## Go命令行操作指令

- 标准go语言项目文件目录格式。
  - 项目文件夹就是GOPATH指向的文件夹。
  - src文件夹是专门用于存放源码文件的。
    - main文件夹是专门用于存储package main包相关源码文件的。
    - 其它文件夹是专门用于存储除package main包以外源码文件的。
  - bin文件夹是专门用于存储编译之后的可执行程序的。
  - pag文件夹是专门用于存储编译之后的.a文件的。
  
  ```
  --项目文件夹
  ----src文件夹
  --------main文件夹
  --------其它文件夹
  ----bin文件夹
  ----pkg文件夹
  ```

- `go version` 查看当前安装的go版本。
- `go env` 查看当前go的环境变量。
- `go fmt` 格式化代码会将指定文件中凌乱的代码按照go语言规范格式化。
- `go run 命令文件` 编译并运行go程序package main包中包含main函数的文件, 我们称之为命令文件其它包中的文件, 我们称之为源码文件。
- `go build` 编译检查对于非命令文件只会执行编译检查, 不会产生任何文件对于命令文件除了编译检查外,还会在当前目录下生成一个可执行文件对应只想编译某个文件, 可以在命令后面指定文件名称`go build 文件名称`。
- `go install` 安装程序对于非命令文件会执行编译检查, 并生成.a结尾的包, 放到 $GOPATH/pkg目录中对于命令文件会执行编译检查, 并生成可执行程序, 放到$GOPATH/bin目录中。

## 通过os包获取命令行参数

- C语言中的命令行参数。
  - argc: argv中保存数据的个数。
  - argv: 默认情况下系统只会传入一个值, 这个值就是main函数执行文件的路径。
  - 我们可以通过配置开发工具,或者命令行运行时以`空格+参数`形式传递其它参数。
  - 注意点: 无论外界传入的是什么类型, 我们拿到的都是`字符串类型`。

```go
#include <stdio.h>
int main(int argc, const char * argv[])
{
    for(int i = 0; i < argc; i++){
        printf("argv[%d] = %s\n", i, argv[i]);
    }
    return 0;
}
```

![](/assets/images/2019Go/go-go07section-01.png)

+ Go语言中的命令行参数
  - Go语言中main函数没有形参, 所以不能直接通过main函数获取命令行参数。
  - 想要获取命令行参数必须导入os包, 通过os包的Args获取。
  - 注意点: 无论外界传入的是什么类型, 我们拿到的都是`字符串类型`。

```go
package main

import (
    "fmt"
    "os" // 用于获取命令行参数的包
)
func main() {
    // 1.获取传入参数个数
    num := len(os.Args)
    // 2.打印所有获取到的参数
    for i := 0; i < num; i++ {
        fmt.Println(os.Args[i])
    }
}
```

![](/assets/images/2019Go/go-go07section-02.png)

## 通过flag包获取命令行参数

- Go语言中除了可以通过os包获取命令行参数以外,还可以通过flag包获取命令行参数。

```go
package main
import (
    "flag"
    "fmt"
)
func main() {
    /*
    flag.Xxxx(name, value, usage)
    第一个参数: 命令行参数名称
    第二个参数: 命令行参数对应的默认值
    第三个参数: 命令行参数对应的说明
    */
    // 1.设置命令行参数
    name := flag.String("name", "hjw", "请输入人的姓名")
    age := flag.Int("age", 33, "请输入人的年龄")
    // 2.将命令行参数解析到注册的参数
    flag.Parse()
    // 3.使用命令行参数
    // 注意flag对应方法返回的都是指针类型, 所以使用时必须通过指针访问
    fmt.Println("name = ", *name)
    fmt.Println("age = ", *age)
}
```

![](/assets/images/2019Go/go-go07section-03.png)

+ flag获取命令行参数第二种写法。

```go
package main
import (
    "flag"
    "fmt"
)
func main() {
    /*
    flag.Xxxx(*type, name, value, usage)
    第一个参数:保存命令行参数变量地址
    第二个参数: 命令行参数名称
    第三个参数: 命令行参数对应的默认值
    第四个参数: 命令行参数对应的说明
    */
    // 1.定义变量,保存命令行参数的值
    var name string
    var age int
    // 2.设置命令行参数
    flag.StringVar(&name, "name", "hjw", "请输入人的姓名")
    flag.IntVar(&age, "age", 33,"请输入人的姓名")
    // 3.注册解析命令行参数
    flag.Parse()
    // 4.使用命令行参数
    fmt.Println("name = ", name)
    fmt.Println("age = ", age)
}
```

## os包和flag包获取命令行参数对比

- 通过os包获取命令行参数
  - 如果用户没有传递参数`会`报错。
  - `需要`严格按照代码中的顺序传递参数, 否则`会`造成数据混乱。
  - `不能`指定参数的名称。
  - 获取到的数据都是`字符串`类型。

```go
package main
import (
    "os"
    "fmt"
)
int main(){
    name := os.Args[1]
    age := os.Args[2]
    fmt.Println("name = ", name)
    fmt.Println("age = ", age)
}
```

![](/assets/images/2019Go/go-go07section-04.png)

+ 通过flag包获取命令行参数
  - 如果用户没有传递参数`不会`报错。
  - `不需要`严格按照代码中的顺序传递参数, `不会`造成数据混乱。
  - `可以`指定参数的名称。
  - 获取到的数据是我们自己指定的类型。

```go
package main
import (
    "flag"
    "fmt"
)
int main(){
    name := flag.String("name", "hjw", "请输入人的姓名")
    age := flag.Int("age", 33, "请输入人的年龄")
    // 2.注册解析命令行参数
    flag.Parse()
    // 3.使用命令行参数
    // 注意flag对应方法返回的都是指针类型, 所以使用时必须通过指针访问
    fmt.Println("name = ", *name)
    fmt.Println("age = ", *age)
}
```

![](/assets/images/2019Go/go-go07section-05.png)